{"language":"Solidity","sources":{"flattened/CTMRWA001X.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.20;\n\n// contracts/c3Caller/IC3Caller.sol\n\nlibrary C3CallerStructLib {\n    struct C3EvmMessage {\n        bytes32 uuid;\n        address to;\n        string fromChainID;\n        string sourceTx;\n        string fallbackTo;\n        bytes data;\n    }\n}\n\ninterface IC3GovClient {\n    function gov() external view returns (address);\n    function pendingGov() external view returns (address);\n    function isOperator(address) external view returns (bool);\n    function changeGov(address _gov) external;\n    function applyGov() external;\n    function addOperator(address _op) external;\n    function getAllOperators() external view returns (address[] memory);\n    function revokeOperator(address _op) external;\n}\n\ninterface IC3CallerProxy {\n    function c3caller() external returns (address);\n    function isExecutor(address sender) external returns (bool);\n\n    function isCaller(address sender) external returns (bool);\n\n    function context()\n        external\n        view\n        returns (\n            bytes32 swapID,\n            string memory fromChainID,\n            string memory sourceTx\n        );\n\n    function c3call(\n        uint256 _dappID,\n        string calldata _to,\n        string calldata _toChainID,\n        bytes calldata _data\n    ) external;\n\n    function c3call(\n        uint256 _dappID,\n        string calldata _to,\n        string calldata _toChainID,\n        bytes calldata _data,\n        bytes memory _extra\n    ) external;\n\n    function c3broadcast(\n        uint256 _dappID,\n        string[] calldata _to,\n        string[] calldata _toChainIDs,\n        bytes calldata _data\n    ) external;\n\n    function execute(\n        uint256 _dappID,\n        C3CallerStructLib.C3EvmMessage calldata _message\n    ) external;\n\n    function c3Fallback(\n        uint256 dappID,\n        C3CallerStructLib.C3EvmMessage calldata _message\n    ) external;\n}\n\ninterface IC3Dapp {\n    function c3Fallback(\n        uint256 dappID,\n        bytes calldata data,\n        bytes calldata reason\n    ) external returns (bool);\n\n    function dappID() external returns (uint256);\n\n    function isValidSender(address txSender) external returns (bool);\n}\n\ninterface IC3Caller {\n    function context()\n        external\n        view\n        returns (\n            bytes32 uuid,\n            string memory fromChainID,\n            string memory sourceTx\n        );\n\n    function c3call(\n        uint256 _dappID,\n        address _caller,\n        string calldata _to,\n        string calldata _toChainID,\n        bytes calldata _data,\n        bytes memory _extra\n    ) external;\n\n    function c3broadcast(\n        uint256 _dappID,\n        address _caller,\n        string[] calldata _to,\n        string[] calldata _toChainIDs,\n        bytes calldata _data\n    ) external;\n\n    function execute(\n        uint256 _dappID,\n        address _txSender,\n        C3CallerStructLib.C3EvmMessage calldata message\n    ) external;\n\n    function c3Fallback(\n        uint256 dappID,\n        address _txSender,\n        C3CallerStructLib.C3EvmMessage calldata message\n    ) external;\n}\n\n// contracts/extensions/ICTMRWA001SlotApprovable.sol\n\n/**\n * @title CTMRWA001 Semi-Fungible Token Standard, optional extension for approval of slot level\n * @dev Interfaces for any contract that wants to support approval of slot level, which allows an\n *  operator to manage one's tokens with the same slot.\n *  See https://docs.continuumdao.org\n * Note: the ERC-165 identifier for this interface is 0xb688be58.\n */\ninterface ICTMRWA001SlotApprovable {\n    /**\n     * @dev MUST emits when an operator is approved or disapproved to manage all of `_owner`'s\n     *  tokens with the same slot.\n     * @param _owner The address whose tokens are approved\n     * @param _slot The slot to approve, all of `_owner`'s tokens with this slot are approved\n     * @param _operator The operator being approved or disapproved\n     * @param _approved Identify if `_operator` is approved or disapproved\n     */\n    event ApprovalForSlot(address indexed _owner, uint256 indexed _slot, address indexed _operator, bool _approved);\n\n    /**\n     * @notice Approve or disapprove an operator to manage all of `_owner`'s tokens with the\n     *  specified slot.\n     * @dev Caller SHOULD be `_owner` or an operator who has been authorized through\n     *  `setApprovalForAll`.\n     *  MUST emit ApprovalSlot event.\n     * @param _owner The address that owns the CTMRWA001 tokens\n     * @param _slot The slot of tokens being queried approval of\n     * @param _operator The address for whom to query approval\n     * @param _approved Identify if `_operator` would be approved or disapproved\n     */\n    function setApprovalForSlot(\n        address _owner,\n        uint256 _slot,\n        address _operator,\n        bool _approved\n    ) external payable;\n\n    /**\n     * @notice Query if `_operator` is authorized to manage all of `_owner`'s tokens with the\n     *  specified slot.\n     * @param _owner The address that owns the CTMRWA001 tokens\n     * @param _slot The slot of tokens being queried approval of\n     * @param _operator The address for whom to query approval\n     * @return True if `_operator` is authorized to manage all of `_owner`'s tokens with `_slot`,\n     *  false otherwise.\n     */\n    function isApprovedForSlot(\n        address _owner,\n        uint256 _slot,\n        address _operator\n    ) external view returns (bool);\n}\n\n// contracts/interfaces/ICTMRWA001Token.sol\n\ninterface ICTMRWA001Token {\n    function getRWAType() external pure returns(uint256);\n    function getVersion() external pure returns(uint256);\n}\n\n// contracts/interfaces/ICTMRWA001XFallback.sol\n\ninterface ICTMRWA001XFallback {\n\n    function rwa001X() external returns(address);\n\n    function rwa001XC3Fallback(\n        bytes4 selector,\n        bytes calldata data,\n        bytes calldata reason\n    ) external returns(bool);\n\n}\n\n// contracts/interfaces/ICTMRWADeployer.sol\n\ninterface ICTMRWADeployer {\n    function deploy(\n        uint256 rwaType,\n        uint256 version,\n        bytes memory deployData\n    ) external returns(address, address);\n}\n\n// contracts/interfaces/ICTMRWAGateway.sol\n\ninterface ICTMRWAGateway {\n    function addXChainInfo(\n        string memory tochainIdStr,\n        string memory toContractStr,\n        string[] memory chainIdsStr,\n        string[] memory contractAddrsStr\n    ) external;\n    function addChainContract(uint256 chainId, address contractAddress) external returns (bool);\n    function getChainContract(string memory chainIdStr) external view returns(string memory);\n    function addXChainInfoX(\n        string[] memory chainIdsStr,\n        string[] memory contractAddrsStr,\n        string memory fromContractStr\n    ) external returns(bool);  // onlyCaller\n    function getAttachedRWAX(\n        string memory _rwaTypeStr, \n        string memory _chainIdStr\n    ) external view returns(bool, string memory);\n    function attachRWAX (\n        string memory _rwaTypeStr, \n        string memory _chainIdStr, \n        string memory _rwaXAddrStr\n    ) external returns(bool);   // onlyGov\n}\n\n// contracts/interfaces/IFeeManager.sol\n\nenum FeeType {\n    ADMIN,\n    DEPLOY,\n    TX,\n    MINT,\n    BURN\n}\n\ninterface IFeeManager {\n    function getXChainFee(\n        string[] memory _toChainIDsStr,\n        bool _includeLocal,\n        FeeType _feeType,\n        string memory _feeTokenStr\n    ) external view returns (uint256);\n\n    function getFeeTokenList() external returns(address[] memory);\n    function isValidFeeToken(string memory feeTokenStr) external view returns(bool);\n    function getFeeTokenIndexMap(string memory) external view returns (uint256);\n    function payFee(uint256 fee, string memory feeTokenStr) external returns (uint256);\n}\n\ninterface IERC20Extended {\n    function decimals() external view returns (uint8);\n}\n\n// contracts/routerV2/TheiaUtils.sol\n\nlibrary TheiaUtils {\n    function fromHexChar(uint8 c) internal pure returns (uint8) {\n        if (bytes1(c) >= bytes1(\"0\") && bytes1(c) <= bytes1(\"9\")) {\n            return c - uint8(bytes1(\"0\"));\n        }\n        if (bytes1(c) >= bytes1(\"a\") && bytes1(c) <= bytes1(\"f\")) {\n            return 10 + c - uint8(bytes1(\"a\"));\n        }\n        if (bytes1(c) >= bytes1(\"A\") && bytes1(c) <= bytes1(\"F\")) {\n            return 10 + c - uint8(bytes1(\"A\"));\n        }\n        return 0;\n    }\n\n    function hexStringToAddress(\n        string memory s\n    ) internal pure returns (bytes memory) {\n        bytes memory ss = bytes(s);\n        require(ss.length % 2 == 0); // length must be even\n        bytes memory r = new bytes(ss.length / 2);\n        for (uint i = 0; i < ss.length / 2; ++i) {\n            r[i] = bytes1(\n                fromHexChar(uint8(ss[2 * i])) *\n                    16 +\n                    fromHexChar(uint8(ss[2 * i + 1]))\n            );\n        }\n\n        return r;\n    }\n\n    function toAddress(string memory s) internal pure returns (address) {\n        bytes memory _bytes = hexStringToAddress(s);\n        require(_bytes.length >= 1 + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(\n                mload(add(add(_bytes, 0x20), 1)),\n                0x1000000000000000000000000\n            )\n        }\n\n        return tempAddress;\n    }\n}\n\n// lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n\n// lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n\n// lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n// lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n\n// contracts/c3Caller/C3CallerDapp.sol\n\nabstract contract C3CallerDapp is IC3Dapp {\n    address public c3CallerProxy;\n    uint256 public dappID;\n\n    modifier onlyCaller() {\n        require(\n            IC3CallerProxy(c3CallerProxy).isCaller(msg.sender),\n            \"C3CallerDapp: onlyCaller\"\n        );\n        _;\n    }\n\n    constructor(address _c3CallerProxy, uint256 _dappID) {\n        c3CallerProxy = _c3CallerProxy;\n        dappID = _dappID;\n    }\n\n    function isCaller(address addr) internal returns (bool) {\n        return IC3CallerProxy(c3CallerProxy).isCaller(addr);\n    }\n\n    function _c3Fallback(\n        bytes4 selector,\n        bytes calldata data,\n        bytes calldata reason\n    ) internal virtual returns (bool);\n\n    function c3Fallback(\n        uint256 _dappID,\n        bytes calldata _data,\n        bytes calldata _reason\n    ) external override onlyCaller returns (bool) {\n        require(_dappID == dappID, \"dappID dismatch\");\n        return _c3Fallback(bytes4(_data[0:4]), _data[4:], _reason);\n    }\n\n    function context()\n        internal\n        view\n        returns (\n            bytes32 uuid,\n            string memory fromChainID,\n            string memory sourceTx\n        )\n    {\n        return IC3CallerProxy(c3CallerProxy).context();\n    }\n\n    function c3call(\n        string memory _to,\n        string memory _toChainID,\n        bytes memory _data\n    ) internal {\n        IC3CallerProxy(c3CallerProxy).c3call(\n            dappID,\n            _to,\n            _toChainID,\n            _data,\n            \"\"\n        );\n    }\n\n    function c3call(\n        string memory _to,\n        string memory _toChainID,\n        bytes memory _data,\n        bytes memory _extra\n    ) internal {\n        IC3CallerProxy(c3CallerProxy).c3call(\n            dappID,\n            _to,\n            _toChainID,\n            _data,\n            _extra\n        );\n    }\n\n    function c3broadcast(\n        string[] memory _to,\n        string[] memory _toChainIDs,\n        bytes memory _data\n    ) internal {\n        IC3CallerProxy(c3CallerProxy).c3broadcast(\n            dappID,\n            _to,\n            _toChainIDs,\n            _data\n        );\n    }\n}\n\n// lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n\n// contracts/c3Caller/C3GovClient.sol\n\ncontract C3GovClient is Initializable, IC3GovClient {\n    address public gov;\n    address public pendingGov;\n    mapping(address => bool) public isOperator;\n    address[] public operators;\n\n    event ChangeGov(\n        address indexed oldGov,\n        address indexed newGov,\n        uint256 timestamp\n    );\n\n    event ApplyGov(\n        address indexed oldGov,\n        address indexed newGov,\n        uint256 timestamp\n    );\n    modifier onlyGov() {\n        require(msg.sender == gov, \"C3Gov: only Gov\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(\n            msg.sender == gov || isOperator[msg.sender],\n            \"C3Gov: only Operator\"\n        );\n        _;\n    }\n\n    function initGov(address _gov) internal initializer {\n        gov = _gov;\n        emit ApplyGov(address(0), _gov, block.timestamp);\n    }\n\n    function changeGov(address _gov) external onlyGov {\n        pendingGov = _gov;\n        emit ChangeGov(gov, _gov, block.timestamp);\n    }\n\n    function applyGov() external {\n        require(pendingGov != address(0), \"C3Gov: empty pendingGov\");\n        gov = pendingGov;\n        pendingGov = address(0);\n        emit ApplyGov(gov, pendingGov, block.timestamp);\n    }\n\n    function _addOperator(address op) internal {\n        require(op != address(0), \"C3Caller: Operator is address(0)\");\n        require(!isOperator[op], \"C3Caller: Operator already exists\");\n        isOperator[op] = true;\n        operators.push(op);\n    }\n\n    function addOperator(address _op) external onlyGov {\n        _addOperator(_op);\n    }\n\n    function getAllOperators() external view returns (address[] memory) {\n        return operators;\n    }\n\n    function revokeOperator(address _op) external onlyGov {\n        require(isOperator[_op], \"C3Caller: Operator not found\");\n        isOperator[_op] = false;\n        uint256 length = operators.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (operators[i] == _op) {\n                operators[i] = operators[length - 1];\n                operators.pop();\n                return;\n            }\n        }\n    }\n}\n\n// lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Enumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\n// lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n// lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/extensions/ICTMRWA001Metadata.sol\n\n/**\n * @title CTMRWA001 Semi-Fungible Token Standard, optional extension for metadata\n * @dev Interfaces for any contract that wants to support query of the Uniform Resource Identifier\n *  (URI) for the CTMRWA001 contract as well as a specified slot.\n *  Because of the higher reliability of data stored in smart contracts compared to data stored in\n *  centralized systems, it is recommended that metadata, including `contractURI`, `slotURI` and\n *  `tokenURI`, be directly returned in JSON format, instead of being returned with a url pointing\n *  to any resource stored in a centralized system.\n *  See https://docs.continuumdao.org\n * Note: the ERC-165 identifier for this interface is 0xe1600902.\n */\ninterface ICTMRWA001Metadata is IERC721Metadata {\n    /**\n     * @notice Returns the Uniform Resource Identifier (URI) for the current CTMRWA001 contract.\n     * @dev This function SHOULD return the URI for this contract in JSON format, starting with\n     *  header `data:application/json;`.\n     *  See https://docs.continuumdao.org for the JSON schema for contract URI.\n     * @return The JSON formatted URI of the current CTMRWA001 contract\n     */\n    function contractURI() external view returns (string memory);\n\n    /**\n     * @notice Returns the Uniform Resource Identifier (URI) for the specified slot.\n     * @dev This function SHOULD return the URI for `_slot` in JSON format, starting with header\n     *  `data:application/json;`.\n     *  See https://docs.continuumdao.org for the JSON schema for slot URI.\n     * @return The JSON formatted URI of `_slot`\n     */\n    function slotURI(uint256 _slot) external view returns (string memory);\n\n    function baseURI() external view returns (string memory);\n}\n\n// contracts/extensions/ICTMRWA001SlotEnumerable.sol\n\n/**\n * @title CTMRWA001 Semi-Fungible Token Standard, optional extension for slot enumeration\n * @dev Interfaces for any contract that wants to support enumeration of slots as well as tokens \n *  with the same slot.\n *  See https://docs.continuumdao.org\n * Note: the ERC-165 identifier for this interface is 0x3b741b9e.\n */\ninterface ICTMRWA001SlotEnumerable is IERC721Enumerable {\n\n    /**\n     * @notice Get the total amount of slots stored by the contract.\n     * @return The total amount of slots\n     */\n    function slotCount() external view returns (uint256);\n\n    /**\n     * @notice Get the slot at the specified index of all slots stored by the contract.\n     * @param _index The index in the slot list\n     * @return The slot at `index` of all slots.\n     */\n    function slotByIndex(uint256 _index) external view returns (uint256);\n\n    /**\n     * @notice Get the total amount of tokens with the same slot.\n     * @param _slot The slot to query token supply for\n     * @return The total amount of tokens with the specified `_slot`\n     */\n    function tokenSupplyInSlot(uint256 _slot) external view returns (uint256);\n\n    /**\n     * @notice Get the token at the specified index of all tokens with the same slot.\n     * @param _slot The slot to query tokens with\n     * @param _index The index in the token list of the slot\n     * @return The token ID at `_index` of all tokens with `_slot`\n     */\n    function tokenInSlotByIndex(uint256 _slot, uint256 _index) external view returns (uint256);\n}\n\n// lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n\n// contracts/interfaces/ICTMRWA001.sol\n\n/**\n * @title CTMRWA001 Semi-Fungible Token Standard\n * @dev See https://docs.continuumdao.org\n * Note: the ERC-165 identifier for this interface is 0xd5358140.\n */\n\nstruct TokenContract {\n    string chainIdStr;\n    string contractStr;\n}\n\ninterface ITokenContract {\n    function tokenContract() external returns(TokenContract[] memory);\n    function tokenChainIdStrs() external returns(string[] memory);\n}\n\ninterface ICTMRWA001 is ICTMRWA001Metadata, ICTMRWA001SlotEnumerable, ICTMRWA001SlotApprovable {\n\n    function ID() external view returns(uint256);\n    function tokenAdmin() external returns(address);\n    function changeAdminX(address _admin) external returns(bool);\n    function addXTokenInfo(\n        address _admin,\n        string[] memory _chainIdsStr,\n        string[] memory _contractAddrsStr\n    ) external returns(bool);\n    \n    function getTokenContract(string memory _chainIdStr) external view returns(string memory);\n    function getTokenInfo(uint256 tokenId_) external view returns(uint256 id,uint256 bal,address owner,uint256 slot);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function valueDecimals() external view returns (uint8);\n    function attachId(uint256 ID, address _admin) external returns(bool);\n    function baseURI() external view returns(string memory);\n    function balanceOf(uint256 _tokenId) external view returns (uint256);\n    function dividendUnclaimedOf(uint256 tokenId) external view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index_) external view returns (uint256);\n    function tokenInSlotByIndex(uint256 slot, uint256 index_) external view returns (uint256);\n    function tokenSupplyInSlot(uint256 slot) external view returns(uint256);\n    function totalSupplyInSlot(uint256 slot) external view returns(uint256);\n    function slotExists(uint256 slot_) external view returns (bool);\n\n    function approveFromX(address to_, uint256 tokenId_) external;\n    function clearApprovedValues(uint256 tokenId_) external;\n    function removeTokenFromOwnerEnumeration(address from_, uint256 tokenId_) external;\n\n    function burnValueX(uint256 fromTokenId, uint256 value_) external returns(bool);\n    function mintValueX(uint256 toTokenId, uint256 slot_, uint256 value_) external returns(bool);\n    function mintFromX(address to, uint256 slot_, uint256 value_) external returns (uint256 tokenId);\n    function mintFromX(address to, uint256 tokenId, uint256 slot, uint256 value) external;\n\n    function spendAllowance(address operator, uint256 tokenId, uint256 value_) external;\n    function requireMinted(uint256 tokenId) external view returns(bool);\n    function isApprovedOrOwner(address operator, uint256 tokenId) external view returns(bool);\n    \n\n    function attachDividend(address dividendAddr) external returns(bool);\n    function dividendAddr() external view returns(address);\n    function getDividendRateBySlot(uint256 _slot) external view returns(uint256);\n    function changeDividendRate(uint256 slot, uint256 dividend) external returns(bool);\n    function incrementDividend(uint256 tokenId, uint256 dividend) external returns(uint256);\n    function decrementDividend(uint256 tokenId, uint256 dividend) external returns(uint256);\n\n    /**\n     * @dev MUST emit when value of a token is transferred to another token with the same slot,\n     *  including zero value transfers (_value == 0) as well as transfers when tokens are created\n     *  (`_fromTokenId` == 0) or destroyed (`_toTokenId` == 0).\n     * @param _fromTokenId The token id to transfer value from\n     * @param _toTokenId The token id to transfer value to\n     * @param _value The transferred value\n     */\n    event TransferValue(uint256 indexed _fromTokenId, uint256 indexed _toTokenId, uint256 _value);\n\n    /**\n     * @dev MUST emits when the approval value of a token is set or changed.\n     * @param _tokenId The token to approve\n     * @param _operator The operator to approve for\n     * @param _value The maximum value that `_operator` is allowed to manage\n     */\n    event ApprovalValue(uint256 indexed _tokenId, address indexed _operator, uint256 _value);\n\n    /**\n     * @dev MUST emit when the slot of a token is set or changed.\n     * @param _tokenId The token of which slot is set or changed\n     * @param _oldSlot The previous slot of the token\n     * @param _newSlot The updated slot of the token\n     */ \n    event SlotChanged(uint256 indexed _tokenId, uint256 indexed _oldSlot, uint256 indexed _newSlot);\n\n    /**\n     * @notice Get the number of decimals the token uses for value - e.g. 6, means the user\n     *  representation of the value of a token can be calculated by dividing it by 1,000,000.\n     *  Considering the compatibility with third-party wallets, this function is defined as\n     *  `valueDecimals()` instead of `decimals()` to avoid conflict with ERC20 tokens.\n     * @return The number of decimals for value\n     */\n\n    /**\n     * @notice Get the value of a token.\n     * @param _tokenId The token for which to query the balance\n     * @return The value of `_tokenId`\n     */\n\n    /**\n     * @notice Get the slot of a token.\n     * @param _tokenId The identifier for a token\n     * @return The slot of the token\n     */\n    function slotOf(uint256 _tokenId) external view returns (uint256);\n\n    /**\n     * @notice Allow an operator to manage the value of a token, up to the `_value` amount.\n     * @dev MUST revert unless caller is the current owner, an authorized operator, or the approved\n     *  address for `_tokenId`.\n     *  MUST emit ApprovalValue event.\n     * @param _tokenId The token to approve\n     * @param _operator The operator to be approved\n     * @param _value The maximum value of `_toTokenId` that `_operator` is allowed to manage\n     */\n    function approve(\n        uint256 _tokenId,\n        address _operator,\n        uint256 _value\n    ) external payable;\n\n    /**\n     * @notice Get the maximum value of a token that an operator is allowed to manage.\n     * @param _tokenId The token for which to query the allowance\n     * @param _operator The address of an operator\n     * @return The current approval value of `_tokenId` that `_operator` is allowed to manage\n     */\n    function allowance(uint256 _tokenId, address _operator) external view returns (uint256);\n\n    /**\n     * @notice Transfer value from a specified token to another specified token with the same slot.\n     * @dev Caller MUST be the current owner, an authorized operator or an operator who has been\n     *  approved the whole `_fromTokenId` or part of it.\n     *  MUST revert if `_fromTokenId` or `_toTokenId` is zero token id or does not exist.\n     *  MUST revert if slots of `_fromTokenId` and `_toTokenId` do not match.\n     *  MUST revert if `_value` exceeds the balance of `_fromTokenId` or its allowance to the\n     *  operator.\n     *  MUST emit `TransferValue` event.\n     * @param _fromTokenId The token to transfer value from\n     * @param _toTokenId The token to transfer value to\n     * @param _value The transferred value\n     */\n    function transferFrom(\n        uint256 _fromTokenId,\n        uint256 _toTokenId,\n        uint256 _value\n    ) external payable;\n\n    /**\n     * @notice Transfer value from a specified token to an address. The caller should confirm that\n     *  `_to` is capable of receiving CTMRWA001 tokens.\n     * @dev This function MUST create a new CTMRWA001 token with the same slot for `_to` to receive\n     *  the transferred value.\n     *  MUST revert if `_fromTokenId` is zero token id or does not exist.\n     *  MUST revert if `_to` is zero address.\n     *  MUST revert if `_value` exceeds the balance of `_fromTokenId` or its allowance to the\n     *  operator.\n     *  MUST emit `Transfer` and `TransferValue` events.\n     * @param _fromTokenId The token to transfer value from\n     * @param _to The address to transfer value to\n     * @param _value The transferred value\n     * @return ID of the new token created for `_to` which receives the transferred value\n     */\n    function transferFrom(\n        uint256 _fromTokenId,\n        address _to,\n        uint256 _value\n    ) external payable returns (uint256);\n}\n\n// contracts/routerV2/GovernDapp.sol\n\nabstract contract GovernDapp is C3CallerDapp {\n    using Strings for *;\n    using Address for address;\n    // delay for timelock functions\n    uint public delay = 2 days;\n\n    address private _oldGov;\n    address private _newGov;\n    uint256 private _newGovEffectiveTime;\n\n    mapping(address => bool) txSenders;\n\n    constructor(\n        address _gov,\n        address _c3callerProxy,\n        address _txSender,\n        uint256 _dappID\n    ) C3CallerDapp(_c3callerProxy, _dappID) {\n        _oldGov = _gov;\n        _newGov = _gov;\n        _newGovEffectiveTime = block.timestamp;\n        txSenders[_txSender] = true;\n    }\n\n    event LogChangeGov(\n        address indexed oldGov,\n        address indexed newGov,\n        uint indexed effectiveTime,\n        uint256 chainID\n    );\n\n    event LogTxSender(address indexed txSender, bool vaild);\n\n    modifier onlyGov() {\n        require(msg.sender == gov() || isCaller(msg.sender), \"Gov FORBIDDEN\");\n        _;\n    }\n\n    function gov() public view returns (address) {\n        if (block.timestamp >= _newGovEffectiveTime) {\n            return _newGov;\n        }\n        return _oldGov;\n    }\n\n    function changeGov(address newGov) external onlyGov {\n        require(newGov != address(0), \"newGov is empty\");\n        _oldGov = gov();\n        _newGov = newGov;\n        _newGovEffectiveTime = block.timestamp + delay;\n        emit LogChangeGov(\n            _oldGov,\n            _newGov,\n            _newGovEffectiveTime,\n            block.chainid\n        );\n    }\n\n    function setDelay(uint _delay) external onlyGov {\n        delay = _delay;\n    }\n\n    function addTxSender(address txSender) external onlyGov {\n        txSenders[txSender] = true;\n        emit LogTxSender(txSender, true);\n    }\n\n    function disableTxSender(address txSender) external onlyGov {\n        txSenders[txSender] = false;\n        emit LogTxSender(txSender, false);\n    }\n\n    function isValidSender(address txSender) external view returns (bool) {\n        return txSenders[txSender];\n    }\n\n    function doGov(\n        string memory _to,\n        string memory _toChainID,\n        bytes memory _data\n    ) external onlyGov {\n        c3call(_to, _toChainID, _data);\n    }\n\n    function doGovBroadcast(\n        string[] memory _targets,\n        string[] memory _toChainIDs,\n        bytes memory _data\n    ) external onlyGov {\n        require(_targets.length == _toChainIDs.length, \"\");\n        c3broadcast(_targets, _toChainIDs, _data);\n    }\n}\n\n// contracts/CTMRWA001X.sol\n\n//import \"forge-std/console.sol\";\n\ncontract CTMRWA001X is Context, GovernDapp {\n    using Strings for *;\n    using SafeERC20 for IERC20;\n\n    address gateway;\n    address public feeManager;\n    address public ctmRwaDeployer;\n    address public fallbackAddr;\n    string public cIdStr;\n\n    mapping(address => address[]) public adminTokens;  // tokenAdmin address => array of CTMRWA001 contracts\n    mapping(address => address[]) public ownedCtmRwa001;  // owner address => array of CTMRWA001 contracts\n\n    //event LogFallback(bytes4 selector, bytes data, bytes reason);\n\n    event CreateNewCTMRWA001(\n        address ctmRwa001Token, \n        uint256 ID, \n        address newAdmin, \n        string fromChainIdStr, \n        string fromContractStr\n    );\n\n    // event ChangeAdmin(uint256 ID, string currentAdminStr, string newAdminStr, string toChainIdStr);\n    event ChangeAdminDest(string currentAdminStr, string newAdminStr, string fromChainIdStr);\n    event AddNewChainAndToken(string fromChainIdStr, string fromContractStr, string[] chainIdsStr, string[] ctmRwa001AddrsStr);\n    // event LockToken(uint256 ID, address ctmRwa001Addr, uint256 nChains);\n\n    // event TransferFromSourceX(\n    //     uint256 ID,\n    //     string fromAddressStr,\n    //     string toAddressStr,\n    //     uint256 fromtokenId,\n    //     uint256 toTokenId,\n    //     uint256 slot,\n    //     uint256 value,\n    //     string fromCtmRwa001AddrStr,\n    //     string toCtmRwa001AddrStr\n    // );\n\n    event TransferToDestX(\n        uint256 ID,\n        string fromAddressStr,\n        string toAddressStr,\n        uint256 fromTokenId,\n        uint256 toTokenId,\n        uint256 slot,\n        uint256 value,\n        string fromContractStr,\n        string ctmRwa001AddrStr\n    );\n\n    // event MintIncrementalTokenValue(\n    //     uint256 ID,\n    //     address minter,\n    //     uint256 toTokenId,\n    //     uint256 slot,\n    //     uint256 value\n    // );\n\n    // event MintTokenValueNewId(\n    //             uint256 ID,\n    //             address minter,\n    //             uint256 newTokenId,\n    //             uint256 slot,\n    //             uint256 value\n    // );\n\n    mapping(uint256 => string) public idToContract;\n    mapping(string => uint256) public contractToId;\n\n    constructor(\n        address _gateway,\n        address _feeManager,\n        address _gov,\n        address _c3callerProxy,\n        address _txSender,\n        uint256 _dappID\n    ) GovernDapp(_gov, _c3callerProxy, _txSender, _dappID) {\n        gateway = _gateway;\n        feeManager = _feeManager;\n        cIdStr = cID().toString();\n    }\n\n    function changeFeeManager(address _feeManager) external onlyGov {\n        feeManager = _feeManager;\n    }\n\n    function setCtmRwaDeployer(address _deployer) external onlyGov {\n        ctmRwaDeployer = _deployer;\n    }\n\n    function setFallback(address _fallbackAddr) external onlyGov {\n        fallbackAddr = _fallbackAddr;\n    }\n\n    \n    function _deployCTMRWA001Local(\n        uint256 _ID,\n        uint256 _rwaType,\n        uint256 _version,\n        string memory tokenName_, \n        string memory symbol_, \n        uint8 decimals_,\n        string memory baseURI_,\n        address tokenAdmin\n    ) internal returns(address) {\n        bool ok = bytes(idToContract[_ID]).length == 0; // only checks local deployments!\n        require(ok, \"CTMRWA001X: A local contract with this ID already exists\");\n\n        bytes memory deployData = abi.encode(_ID, tokenAdmin, tokenName_, symbol_, decimals_, baseURI_, address(this));\n\n        (address ctmRwa001Token, address dividendAddr) = ICTMRWADeployer(ctmRwaDeployer).deploy(\n            _rwaType,\n            _version,\n            deployData\n        );\n\n        ok = _attachCTMRWA001ID(_ID, ctmRwa001Token);\n        require(ok, \"CTMRWA001X: Failed to set token ID\");\n\n        ok = ICTMRWA001(ctmRwa001Token).attachDividend(dividendAddr);\n        require(ok, \"CTMRWA001X: Failed to set the dividend contract address\");\n\n        ICTMRWA001(ctmRwa001Token).changeAdminX(tokenAdmin);\n        adminTokens[tokenAdmin].push(ctmRwa001Token);\n\n        emit CreateNewCTMRWA001(ctmRwa001Token, _ID, tokenAdmin, cID().toString(), \"\");\n\n        return(ctmRwa001Token);\n    }\n\n   \n\n    function deployAllCTMRWA001X(\n        bool _includeLocal,\n        uint256 _existingID,\n        uint256 _rwaType,\n        uint256 _version,\n        string memory _tokenName, \n        string memory _symbol, \n        uint8 _decimals,\n        string memory _baseURI,\n        string[] memory _toChainIdsStr,\n        string memory _feeTokenStr\n    ) public returns(uint256) {\n        require(!_includeLocal && _existingID>0 || _includeLocal && _existingID == 0, \"CTMRWA001X: Incorrect call logic\");\n        uint256 nChains = _toChainIdsStr.length;\n\n        string memory ctmRwa001AddrStr;\n        address ctmRwa001Addr;\n        address currentAdmin;\n        uint256 ID;\n        string memory tokenName;\n        string memory symbol;\n        uint8 decimals;\n        string memory baseURI;\n\n        if(_includeLocal) {\n            // generate a new ID\n            ID = uint256(keccak256(abi.encode(\n                _tokenName,\n                _symbol,\n                _decimals,\n                block.timestamp,\n                _msgSender()\n            )));\n\n            tokenName = _tokenName;\n            symbol = _symbol;\n            decimals = _decimals;\n            baseURI = _baseURI;\n\n            ctmRwa001Addr = _deployCTMRWA001Local(ID, _rwaType, _version, _tokenName, _symbol, _decimals, baseURI, _msgSender());\n            ICTMRWA001(ctmRwa001Addr).changeAdminX(_msgSender());\n            \n            currentAdmin = _msgSender();\n        } else {  // a CTMRWA001 token must be deployed already, so use the existing ID\n            ID = _existingID;\n            (bool ok, address rwa001Addr) = this.getAttachedTokenAddress(ID);\n            require(ok, \"CTMRWA001X: ID does not exist on local chain\");\n            ctmRwa001Addr = rwa001Addr;\n            currentAdmin = ICTMRWA001(ctmRwa001Addr).tokenAdmin();\n            require(_msgSender() == currentAdmin, \"CTMRWA001X: Only tokenAdmin can deploy\");\n\n            tokenName = ICTMRWA001(ctmRwa001Addr).name();\n            symbol = ICTMRWA001(ctmRwa001Addr).symbol();\n            decimals = ICTMRWA001(ctmRwa001Addr).valueDecimals();\n            baseURI = ICTMRWA001(ctmRwa001Addr).baseURI();\n        }\n\n        ctmRwa001AddrStr = _toLower(ctmRwa001Addr.toHexString());\n\n        _payFee(FeeType.DEPLOY, _feeTokenStr, _toChainIdsStr, _includeLocal);\n\n        for(uint256 i=0; i<nChains; i++){\n            _deployCTMRWA001X(\n                tokenName, \n                symbol,\n                decimals, \n                baseURI,\n                _toChainIdsStr[i], \n                ctmRwa001AddrStr\n            );\n        }\n\n        return(ID);\n\n    }\n\n    // Deploys a new CTMRWA001 instance on a destination chain, \n    // recovering the ID from a required local instance of CTMRWA001, owned by tokenAdmin\n    function _deployCTMRWA001X(\n        string memory _tokenName, \n        string memory _symbol, \n        uint8 _decimals,\n        string memory _baseURI,\n        string memory _toChainIdStr,\n        string memory _ctmRwa001AddrStr\n    ) internal returns (bool) {\n        require(!stringsEqual(_toChainIdStr, cID().toString()), \"CTMRWA001X: Not a cross-chain transfer\");\n        address ctmRwa001Addr = stringToAddress(_ctmRwa001AddrStr);\n\n        (, string memory currentAdminStr) = _checkTokenAdmin(ctmRwa001Addr);\n\n        uint256 ID = ICTMRWA001(ctmRwa001Addr).ID();\n        uint256 rwaType = ICTMRWA001Token(ctmRwa001Addr).getRWAType();\n        uint256 version = ICTMRWA001Token(ctmRwa001Addr).getVersion();\n        \n        string memory gatewayStr = ICTMRWAGateway(gateway).getChainContract(_toChainIdStr);\n        require(bytes(gatewayStr).length>0, \"CTMRWA001X: Target contract address not found\");\n\n        string memory funcCall = \"deployCTMRWA001(string,uint256,uint256,uint256,string,string,uint8,string,string)\";\n        bytes memory callData = abi.encodeWithSignature(\n            funcCall,\n            currentAdminStr,\n            ID,\n            rwaType,\n            version,\n            _tokenName,\n            _symbol,\n            _decimals,\n            _baseURI,\n            _ctmRwa001AddrStr\n        );\n\n        c3call(gatewayStr, _toChainIdStr, callData);\n\n        return(true);\n        \n    }\n\n    // Deploys a new CTMRWA001 instance on a destination chain, \n    // with the ID sent from a required local instance of CTMRWA001, owned by tokenAdmin\n    function deployCTMRWA001(\n        string memory _newAdminStr,\n        uint256 _ID,\n        uint256 _rwaType,\n        uint256 _version,\n        string memory _tokenName, \n        string memory _symbol, \n        uint8 _decimals,\n        string memory _baseURI,\n        string memory _fromContractStr\n    ) external onlyCaller returns(bool) {\n\n        address newAdmin = stringToAddress(_newAdminStr);\n\n        (, string memory fromChainIdStr,) = context();\n        fromChainIdStr = _toLower(fromChainIdStr);\n\n        bytes memory deployData = abi.encode(_ID, newAdmin, _tokenName, _symbol, _decimals, _baseURI, address(this));\n\n        (address ctmRwa001Token, address dividendAddr) = ICTMRWADeployer(ctmRwaDeployer).deploy(\n            _rwaType,\n            _version,\n            deployData\n        );\n\n        bool ok = _attachCTMRWA001ID(_ID, ctmRwa001Token);\n        require(ok, \"CTMRWA001X: Failed to set token ID\");\n\n        ok = ICTMRWA001(ctmRwa001Token).attachDividend(dividendAddr);\n        require(ok, \"CTMRWA001X: Failed to set the dividend contract address\");\n\n        ICTMRWA001(ctmRwa001Token).changeAdminX(newAdmin);\n        adminTokens[newAdmin].push(ctmRwa001Token);\n\n        emit CreateNewCTMRWA001(ctmRwa001Token, _ID, newAdmin, fromChainIdStr, _fromContractStr);\n\n        return(true);\n    }\n\n    function changeAdmin(address _newAdmin, uint256 _ID) external returns(bool) {\n\n        (address ctmRwa001Addr,) = _getTokenAddr(_ID);\n        _checkTokenAdmin(ctmRwa001Addr);\n\n        ICTMRWA001(ctmRwa001Addr).changeAdminX(_newAdmin);\n        adminTokens[_newAdmin].push(ctmRwa001Addr);\n\n        // emit ChangeAdmin(_ID, currentAdminStr, _newAdmin.toHexString(), \"\");\n\n        return(true);\n    }\n\n    \n    // Change the tokenAdmin address of a deployed CTMRWA001 instance on another chain\n    function changeAdminCrossChain(\n        string memory _newAdminStr,\n        string memory _toChainIdStr,\n        uint256 _ID,\n        string memory _feeTokenStr\n    ) public returns(bool) {\n        \n        (address ctmRwa001Addr, string memory ctmRwa001AddrStr) = _getTokenAddr(_ID);\n        (, string memory toRwaXStr, string memory toTokenStr) = _getRWAXAndToken(_toChainIdStr, ctmRwa001Addr);\n        (, string memory currentAdminStr) = _checkTokenAdmin(ctmRwa001Addr);\n\n        _payFee(FeeType.ADMIN, _feeTokenStr, _stringToArray(_toChainIdStr), false);\n\n        string memory funcCall = \"adminX(string,string,string,string)\";\n        bytes memory callData = abi.encodeWithSignature(\n            funcCall,\n            currentAdminStr,\n            _newAdminStr,\n            ctmRwa001AddrStr,\n            toTokenStr\n        );\n\n        c3call(toRwaXStr, _toChainIdStr, callData);\n\n        // emit ChangeAdmin(_ID, currentAdminStr, _newAdminStr, _toChainIdStr);\n\n        return(true);\n    }\n\n    function adminX(\n        string memory _currentAdminStr,\n        string memory _newAdminStr,\n        string memory _fromContractStr,\n        string memory _ctmRwa001AddrStr\n    ) external onlyCaller returns(bool) {\n        address ctmRwa001Addr = stringToAddress(_ctmRwa001AddrStr);\n        address newAdmin = stringToAddress(_newAdminStr);\n\n        (, string memory fromChainIdStr,) = context();\n        fromChainIdStr = _toLower(fromChainIdStr);\n\n        string memory storedContractStr = ICTMRWA001(ctmRwa001Addr).getTokenContract(fromChainIdStr);\n        require(stringsEqual(storedContractStr, _fromContractStr), \"CTMRWA001X: From an invalid CTMRWA001\");\n\n        ICTMRWA001(ctmRwa001Addr).changeAdminX(newAdmin);\n        adminTokens[newAdmin].push(ctmRwa001Addr);\n\n        emit ChangeAdminDest(_currentAdminStr, _newAdminStr, fromChainIdStr);\n\n        return(true);\n    }\n\n    function getAllTokensByAdminAddress(address _admin) public view returns(address[] memory) {\n        return(adminTokens[_admin]);\n    }\n\n    function getAllTokensByOwnerAddress(address _owner) public view returns(address[] memory) {\n        return(ownedCtmRwa001[_owner]);\n    }\n\n    function isOwnedToken(address _owner, address _ctmRwa001Addr) public view returns(bool) {\n        if(ICTMRWA001(_ctmRwa001Addr).balanceOf(_owner) > 0) return(true);\n        else return(false);\n    }\n\n    function getAttachedID(address _ctmRwa001Addr) external view returns(bool, uint256) {\n\n        string memory ctmRwa001Addr = _toLower(_ctmRwa001Addr.toHexString());\n        uint256 id = contractToId[ctmRwa001Addr];\n        return (id != 0, id);\n    }\n\n    function getAttachedTokenAddress(uint256 _ID) external view returns(bool, address) {\n        \n        string memory _contractStr = idToContract[_ID];\n       \n        return bytes(_contractStr).length != 0 ? (true, stringToAddress(_contractStr)) : (false, address(0));\n    }\n\n    // Keeps a record of token IDs in this contract. Check offline to see if other contracts have it\n    function _attachCTMRWA001ID(uint256 _ID, address _ctmRwa001Addr) internal returns(bool) {\n\n        if (bytes(idToContract[_ID]).length == 0) {\n            bool ok = ICTMRWA001(_ctmRwa001Addr).attachId(_ID, _msgSender());\n            if (ok) {\n                string memory ctmRwa001Addr = _toLower(_ctmRwa001Addr.toHexString());\n                idToContract[_ID] = ctmRwa001Addr;\n                contractToId[ctmRwa001Addr] = _ID;\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // Add an array of new chainId/ctmRwa001Addr pairs corresponding to other chain deployments\n    function addNewChainIdAndToken(\n        string memory _toChainIdStr,\n        string[] memory _chainIdsStr,\n        string[] memory _otherCtmRwa001AddrsStr,\n        uint256 _ID\n    ) public {\n       \n        (address ctmRwa001Addr, string memory ctmRwa001AddrStr) = _getTokenAddr(_ID);\n        (, string memory toRwaXStr, string memory toTokenStr) = _getRWAXAndToken(_toChainIdStr, ctmRwa001Addr);\n        (, string memory currentAdminStr) = _checkTokenAdmin(ctmRwa001Addr);\n\n        string memory funcCall = \"addNewChainIdAndTokenX(uint256,string,string[],string[],string,string)\";\n        bytes memory callData = abi.encodeWithSignature(\n            funcCall,\n            _ID,\n            currentAdminStr,\n            _chainIdsStr,\n            _otherCtmRwa001AddrsStr,\n            ctmRwa001AddrStr,\n            toTokenStr\n        );\n\n        c3call(toRwaXStr, _toChainIdStr, callData);\n\n    }\n\n    function addNewChainIdAndTokenX(\n        uint256 _Id,\n        string memory _adminStr,\n        string[] memory _chainIdsStr,\n        string[] memory _otherCtmRwa001AddrsStr,\n        string memory _fromTokenStr,\n        string memory _ctmRwa001AddrStr\n    ) external onlyCaller returns(bool) {\n\n        (, string memory fromChainIdStr,) = context();\n        fromChainIdStr = _toLower(fromChainIdStr);\n\n        address tokenAdmin = stringToAddress(_adminStr);\n        address ctmRwa001Addr = stringToAddress(_ctmRwa001AddrStr);\n\n        address currentAdmin = ICTMRWA001(ctmRwa001Addr).tokenAdmin();\n        require(tokenAdmin == currentAdmin, \"CTMRWA001X: No tokenAdmin access to add chains/contracts\");\n\n        (bool ok, uint256 ID) = this.getAttachedID(ctmRwa001Addr);\n        require(ok && ID == _Id, \"CTMRWA001X: Incorrect or unattached CTMRWA001 contract\");\n\n        bool success = ICTMRWA001(ctmRwa001Addr).addXTokenInfo(\n            tokenAdmin, \n            _chainIdsStr, \n            _otherCtmRwa001AddrsStr\n        );\n\n        if(!success) revert(\"CTMRWA001X: addNewChainIdAndToken failed\");\n\n        emit AddNewChainAndToken(fromChainIdStr, _fromTokenStr, _chainIdsStr, _otherCtmRwa001AddrsStr);\n\n        return(true);\n    }\n\n    function mintNewTokenValueLocal(\n        address toAddress_,\n        uint256 toTokenId_,  // Set to 0 to create a newTokenId\n        uint256 slot_,\n        uint256 value_,\n        uint256 _ID\n    ) public returns(uint256) {\n\n        (address ctmRwa001Addr, ) = _getTokenAddr(_ID);\n        _checkTokenAdmin(ctmRwa001Addr);\n\n        if(toTokenId_>0) {\n            ICTMRWA001(ctmRwa001Addr).mintValueX(toTokenId_, slot_, value_);\n\n            // emit MintIncrementalTokenValue(\n            //     _ID,\n            //     _msgSender(),\n            //     toTokenId_,\n            //     slot_,\n            //     value_\n            // );\n            return(toTokenId_);\n        } else {\n            uint256 newTokenId = ICTMRWA001(ctmRwa001Addr).mintFromX(toAddress_, slot_, value_);\n            (,,address owner,) = ICTMRWA001(ctmRwa001Addr).getTokenInfo(newTokenId);\n            ownedCtmRwa001[owner].push(ctmRwa001Addr);\n\n            // emit MintTokenValueNewId(\n            //     _ID,\n            //     _msgSender(),\n            //     newTokenId,\n            //     slot_,\n            //     value_\n            // );\n            return(newTokenId);\n        }\n\n    }\n\n    function mintNewTokenValueX(\n        string memory _toAddressStr,\n        string memory _toChainIdStr,\n        uint256 _slot,\n        uint256 _value,\n        uint256 _ID,\n        string memory _feeTokenStr\n    ) public {\n\n        (address ctmRwa001Addr, string memory ctmRwa001AddrStr) = _getTokenAddr(_ID);\n        (string memory fromAddressStr, string memory toRwaXStr, string memory toTokenStr) = _getRWAXAndToken(_toChainIdStr, ctmRwa001Addr);\n        _checkTokenAdmin(ctmRwa001Addr);\n\n        _payFee(FeeType.MINT, _feeTokenStr, _stringToArray(_toChainIdStr), false);\n\n        string memory funcCall = \"mintX(uint256,string,string,uint256,uint256,uint256,string,string)\";\n        bytes memory callData = abi.encodeWithSignature(\n            funcCall,\n            _ID,\n            fromAddressStr,\n            _toAddressStr,\n            0,  // Not used, since we are not transferring value from a tokenId, but creating new value\n            _slot,\n            _value,\n            ctmRwa001AddrStr,\n            toTokenStr\n        );\n\n        c3call(toRwaXStr, _toChainIdStr, callData);\n    }\n\n    \n    function transferFromX(\n        uint256 _fromTokenId,\n        string memory _toAddressStr,\n        string memory _toChainIdStr,\n        uint256 _value,\n        uint256 _ID,\n        string memory _feeTokenStr\n    ) public {\n        require(bytes(_toAddressStr).length>0, \"CTMRWA001X: Destination address has zero length\");\n\n        (address ctmRwa001Addr,) = _getTokenAddr(_ID);\n        (string memory fromAddressStr, string memory toRwaXStr, string memory toTokenStr) = _getRWAXAndToken(_toChainIdStr, ctmRwa001Addr);\n        \n        ICTMRWA001(ctmRwa001Addr).spendAllowance(_msgSender(), _fromTokenId, _value);\n\n        _payFee(FeeType.TX, _feeTokenStr, _stringToArray(_toChainIdStr), false);\n\n        uint256 slot = ICTMRWA001(ctmRwa001Addr).slotOf(_fromTokenId);\n\n        ICTMRWA001(ctmRwa001Addr).burnValueX(_fromTokenId, _value);\n\n        string memory funcCall = \"mintX(uint256,string,string,uint256,uint256,uint256,string,string)\";\n        \n        bytes memory callData = abi.encodeWithSignature(\n            funcCall,\n            _ID,\n            fromAddressStr,\n            _toAddressStr,\n            _fromTokenId,\n            slot,\n            _value,\n            ctmRwa001Addr,\n            toTokenStr\n        );\n        \n        c3call(toRwaXStr, _toChainIdStr, callData);\n\n        // emit TransferFromSourceX(\n        //     _ID,\n        //     fromAddressStr,\n        //     _toAddressStr,\n        //     _fromTokenId,\n        //     0,\n        //     slot,\n        //     _value,\n        //     ctmRwa001AddrStr,\n        //     toTokenStr\n        // );\n    }\n\n    function transferFromX(\n        uint256 _fromTokenId,\n        string memory _toAddressStr,\n        uint256 _toTokenId,\n        string memory _toChainIdStr,\n        uint256 _value,\n        uint256 _ID,\n        string memory _feeTokenStr\n    ) public {\n        \n        (address ctmRwa001Addr, string memory ctmRwa001AddrStr) = _getTokenAddr(_ID);\n        (string memory fromAddressStr, string memory toRwaXStr, string memory toTokenStr) = _getRWAXAndToken(_toChainIdStr, ctmRwa001Addr);\n        \n        ICTMRWA001(ctmRwa001Addr).spendAllowance(_msgSender(), _fromTokenId, _value);\n        require(bytes(_toAddressStr).length>0, \"CTMRWA001X: Destination address has zero length\");\n\n        _payFee(FeeType.TX, _feeTokenStr, _stringToArray(_toChainIdStr), false);\n\n        uint256 slot = ICTMRWA001(ctmRwa001Addr).slotOf(_fromTokenId);\n\n        ICTMRWA001(ctmRwa001Addr).burnValueX(_fromTokenId, _value);\n\n        string memory funcCall = \"mintX(uint256,string,string,uint256,uint256,uint256,uint256,string,string)\";\n        \n        bytes memory callData = abi.encodeWithSignature(\n            funcCall,\n            _ID,\n            fromAddressStr,\n            _toAddressStr,\n            _fromTokenId,\n            _toTokenId,\n            slot,\n            _value,\n            ctmRwa001AddrStr,\n            toTokenStr\n        );\n        \n        c3call(toRwaXStr, _toChainIdStr, callData);\n\n        // emit TransferFromSourceX(\n        //     _ID,\n        //     fromAddressStr,\n        //     _toAddressStr,\n        //     _fromTokenId,\n        //     _toTokenId,\n        //     slot,\n        //     _value,\n        //     ctmRwa001AddrStr,\n        //     toRwaXStr\n        // );\n    }\n\n    function mintX(\n        uint256 _ID,\n        string memory _fromAddressStr,\n        string memory _toAddressStr,\n        uint256 _fromTokenId,\n        uint256 _toTokenId,\n        uint256 _slot,\n        uint256 _value,\n        string memory _fromContractStr,\n        string memory _ctmRwa001AddrStr\n    ) external onlyCaller returns(bool){\n\n        address ctmRwa001Addr = stringToAddress(_ctmRwa001AddrStr);\n\n        (, string memory fromChainIdStr,) = context();\n        fromChainIdStr = _toLower(fromChainIdStr);\n\n        require(ICTMRWA001(ctmRwa001Addr).ID() == _ID, \"CTMRWA001X: Destination CTMRWA001 ID is incorrect\");\n\n        string memory storedContractStr = ICTMRWA001(ctmRwa001Addr).getTokenContract(fromChainIdStr);\n        require(stringsEqual(storedContractStr, _fromContractStr), \"CTMRWA001X: From an invalid CTMRWA001\");\n\n        ICTMRWA001(ctmRwa001Addr).mintValueX(_toTokenId, _slot, _value);\n        (,,address owner,) = ICTMRWA001(ctmRwa001Addr).getTokenInfo(_toTokenId);\n        ownedCtmRwa001[owner].push(ctmRwa001Addr);\n\n        emit TransferToDestX(\n            _ID,\n            _fromAddressStr,\n            _toAddressStr,\n            _fromTokenId,\n            _toTokenId,\n            _slot,\n            _value,\n            _fromContractStr,\n            _ctmRwa001AddrStr\n        );\n\n        return(true);\n    }\n\n    function transferFromX(\n        string memory _toAddressStr,\n        string memory _toChainIdStr,\n        uint256 _fromTokenId,\n        uint256 _ID,\n        string memory _feeTokenStr\n    ) public {\n\n        (address ctmRwa001Addr, string memory ctmRwa001AddrStr) = _getTokenAddr(_ID);\n        (string memory fromAddressStr, string memory toRwaXStr, string memory toTokenStr) = _getRWAXAndToken(_toChainIdStr, ctmRwa001Addr);\n        \n        require(ICTMRWA001(ctmRwa001Addr).isApprovedOrOwner(_msgSender(), _fromTokenId), \"CTMRWA001X: transfer caller is not owner nor approved\");\n\n        _payFee(FeeType.TX, _feeTokenStr, _stringToArray(_toChainIdStr), false);\n\n        (,uint256 value,,uint256 slot) = ICTMRWA001(ctmRwa001Addr).getTokenInfo(_fromTokenId);\n\n        ICTMRWA001(ctmRwa001Addr).approveFromX(address(0), _fromTokenId);\n        ICTMRWA001(ctmRwa001Addr).clearApprovedValues(_fromTokenId);\n\n        ICTMRWA001(ctmRwa001Addr).removeTokenFromOwnerEnumeration(_msgSender(), _fromTokenId);\n\n        string memory funcCall = \"mintX(uint256,string,string,uint256,uint256,uint256,string,string)\";\n        bytes memory callData = abi.encodeWithSignature(\n            funcCall,\n            _ID,\n            fromAddressStr,\n            _toAddressStr,\n            _fromTokenId,\n            slot,\n            value,\n            ctmRwa001AddrStr,\n            toTokenStr\n        );\n\n        c3call(toRwaXStr, _toChainIdStr, callData);\n\n        // emit TransferFromSourceX(\n        //     _ID,\n        //     fromAddressStr,\n        //     _toAddressStr,\n        //     _fromTokenId,\n        //     0,\n        //     slot,\n        //     value,\n        //     ctmRwa001AddrStr,\n        //     toTokenStr\n        // );\n    }\n\n    function mintX(\n        uint256 _ID,\n        string memory _fromAddressStr,\n        string memory _toAddressStr,\n        uint256 _fromTokenId,\n        uint256 _slot,\n        uint256 _balance,\n        string memory _fromContractStr,\n        string memory _ctmRwa001AddrStr\n    ) external onlyCaller returns(bool){\n\n        (, string memory fromChainIdStr,) = context();\n        fromChainIdStr = _toLower(fromChainIdStr);\n\n        address ctmRwa001Addr = stringToAddress(_ctmRwa001AddrStr);\n        address toAddr = stringToAddress(_toAddressStr);\n\n        require(ICTMRWA001(ctmRwa001Addr).ID() == _ID, \"CTMRWA001X: Destination CTMRWA001 ID is incorrect\");\n\n        string memory storedContractStr = ICTMRWA001(ctmRwa001Addr).getTokenContract(fromChainIdStr);\n        require(stringsEqual(storedContractStr, _fromContractStr), \"CTMRWA001X: From an invalid CTMRWA001\");\n\n        uint256 newTokenId = ICTMRWA001(ctmRwa001Addr).mintFromX(toAddr, _slot, _balance);\n\n        emit TransferToDestX(\n            _ID,\n            _fromAddressStr,\n            _toAddressStr,\n            _fromTokenId,\n            newTokenId,\n            _slot,\n            _balance,\n            _fromContractStr,\n            _ctmRwa001AddrStr\n        );\n\n        return(true);\n    }\n\n    // End of cross chain transfers\n\n    function _getTokenAddr(uint256 _ID) internal view returns(address, string memory) {\n        (bool ok, address ctmRwa001Addr) = this.getAttachedTokenAddress(_ID);\n        require(ok, \"CTMRWA001X: The requested tokenID does not exist\");\n        string memory ctmRwa001AddrStr = _toLower(ctmRwa001Addr.toHexString());\n\n        return(ctmRwa001Addr, ctmRwa001AddrStr);\n    }\n\n    function _getRWAXAndToken(string memory _toChainIdStr, address _tokenAddr) internal view returns(string memory, string memory, string memory) {\n        require(!stringsEqual(_toChainIdStr, cIdStr), \"CTMRWA001X: Not a cross-chain tokenAdmin change\");\n        \n        string memory fromAddressStr = _msgSender().toHexString();\n        string memory toTokenStr = ICTMRWA001(_tokenAddr).getTokenContract(_toChainIdStr);\n\n        (bool ok, string memory toRwaXStr) = ICTMRWAGateway(gateway).getAttachedRWAX(\"RWA001\", _toChainIdStr);\n        require(ok, \"CTMRWA001X: Target contract address not found\");\n\n        return(fromAddressStr, toRwaXStr, toTokenStr);\n    }\n\n    function _checkTokenAdmin(address _tokenAddr) internal returns(address, string memory) {\n        address currentAdmin = ICTMRWA001(_tokenAddr).tokenAdmin();\n        string memory currentAdminStr = currentAdmin.toHexString();\n\n        require(_msgSender() == currentAdmin, \"CTMRWA001X: Only tokenAdmin can change the tokenAdmin\");\n\n        return(currentAdmin, currentAdminStr);\n    }\n\n    function _payFee(\n        FeeType _feeType, \n        string memory _feeTokenStr, \n        string[] memory _toChainIdsStr,\n        bool _includeLocal\n    ) internal returns(bool) {\n        uint256 fee = IFeeManager(feeManager).getXChainFee(_toChainIdsStr, _includeLocal, _feeType, _feeTokenStr);\n        if(fee>0) {\n            address feeToken = stringToAddress(_feeTokenStr);\n            uint256 feeWei = fee*10**(IERC20Extended(feeToken).decimals()-2);\n            IERC20(feeToken).transferFrom(_msgSender(), address(this), feeWei);\n            IERC20(feeToken).approve(feeManager, feeWei);\n            IFeeManager(feeManager).payFee(feeWei, _feeTokenStr);\n        }\n        return(true);\n    }\n\n    function _stringToArray(string memory _string) internal pure returns(string[] memory) {\n        string[] memory strArray = new string[](1);\n        strArray[0] = _string;\n        return(strArray);\n    }\n\n    function cID() internal view returns (uint256) {\n        return block.chainid;\n    }\n\n    function strToUint(\n        string memory _str\n    ) public pure returns (uint256 res, bool err) {\n        if (bytes(_str).length == 0) {\n            return (0, true);\n        }\n        for (uint256 i = 0; i < bytes(_str).length; i++) {\n            if (\n                (uint8(bytes(_str)[i]) - 48) < 0 ||\n                (uint8(bytes(_str)[i]) - 48) > 9\n            ) {\n                return (0, false);\n            }\n            res +=\n                (uint8(bytes(_str)[i]) - 48) *\n                10 ** (bytes(_str).length - i - 1);\n        }\n\n        return (res, true);\n    }\n\n    function stringToAddress(string memory str) public pure returns (address) {\n        bytes memory strBytes = bytes(str);\n        require(strBytes.length == 42, \"CTMRWA001X: Invalid address length\");\n        bytes memory addrBytes = new bytes(20);\n\n        for (uint i = 0; i < 20; i++) {\n            addrBytes[i] = bytes1(\n                hexCharToByte(strBytes[2 + i * 2]) *\n                    16 +\n                    hexCharToByte(strBytes[3 + i * 2])\n            );\n        }\n\n        return address(uint160(bytes20(addrBytes)));\n    }\n\n    function hexCharToByte(bytes1 char) internal pure returns (uint8) {\n        uint8 byteValue = uint8(char);\n        if (\n            byteValue >= uint8(bytes1(\"0\")) && byteValue <= uint8(bytes1(\"9\"))\n        ) {\n            return byteValue - uint8(bytes1(\"0\"));\n        } else if (\n            byteValue >= uint8(bytes1(\"a\")) && byteValue <= uint8(bytes1(\"f\"))\n        ) {\n            return 10 + byteValue - uint8(bytes1(\"a\"));\n        } else if (\n            byteValue >= uint8(bytes1(\"A\")) && byteValue <= uint8(bytes1(\"F\"))\n        ) {\n            return 10 + byteValue - uint8(bytes1(\"A\"));\n        }\n        revert(\"Invalid hex character\");\n    }\n\n    function stringsEqual(\n        string memory a,\n        string memory b\n    ) public pure returns (bool) {\n        bytes32 ka = keccak256(abi.encode(a));\n        bytes32 kb = keccak256(abi.encode(b));\n        return (ka == kb);\n    }\n\n    function _toLower(string memory str) internal pure returns (string memory) {\n        bytes memory bStr = bytes(str);\n        bytes memory bLower = new bytes(bStr.length);\n        for (uint i = 0; i < bStr.length; i++) {\n            // Uppercase character...\n            if ((uint8(bStr[i]) >= 65) && (uint8(bStr[i]) <= 90)) {\n                // So we add 32 to make it lowercase\n                bLower[i] = bytes1(uint8(bStr[i]) + 32);\n            } else {\n                bLower[i] = bStr[i];\n            }\n        }\n        return string(bLower);\n    }\n\n    function _c3Fallback(\n        bytes4 _selector,\n        bytes calldata _data,\n        bytes calldata _reason\n    ) internal override returns (bool) {\n\n        bool ok = ICTMRWA001XFallback(fallbackAddr).rwa001XC3Fallback(\n            _selector,\n            _data,\n            _reason\n        );\n\n        //emit LogFallback(_selector, _data, _reason);\n        return ok;\n    }\n\n}\n"}},"settings":{"remappings":["@openzeppelin/contracts/=lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/","@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/","@openzeppelin/foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/","ds-test/=lib/forge-std/lib/ds-test/src/","forge-std/=lib/forge-std/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin-foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/","solidity-stringutils/=lib/openzeppelin-foundry-upgrades/lib/solidity-stringutils/"],"optimizer":{"enabled":true,"runs":1000000},"viaIR:true,"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":true,"libraries":{}}}
